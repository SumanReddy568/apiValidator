{
    "sourceFile": "js/ui/filters.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1747661990453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747662103776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n import { showNotification } from '../utils/notifications.js';\n import { formatResponse } from './formatToggle.js';\n import { syntaxHighlight } from '../utils/formatting.js';\n import { getNestedValue } from '../utils/objectUtils.js';\n-import { operators, applyFilters } from '../utils/filterUtils.js';\n \n export function initFilterFunctionality() {\n     // Add filter event listeners\n     const applyFilterBtn = document.getElementById('apply-filter');\n@@ -48,52 +47,10 @@\n         filterQuery.addEventListener('input', () => {\n             if (window.appState.lastResponse) filterResponse(filterQuery.value);\n         });\n     }\n-\n-    // Update operator select options\n-    const filterOperator = document.getElementById('filter-operator');\n-    if (filterOperator) {\n-        filterOperator.innerHTML = Object.entries(operators)\n-            .map(([key, op]) => `<option value=\"${key}\">${op.label}</option>`)\n-            .join('');\n-        filterOperator.style.display = 'inline-block';\n-    }\n-\n-    // Show operator select based on field type\n-    document.getElementById('filter-type').addEventListener('change', (e) => {\n-        const fieldType = getFieldType(e.target.value);\n-        updateOperatorOptions(fieldType);\n-    });\n }\n \n-function updateOperatorOptions(fieldType) {\n-    const operatorSelect = document.getElementById('filter-operator');\n-    if (!operatorSelect) return;\n-\n-    const availableOperators = Object.entries(operators)\n-        .filter(([key, op]) => {\n-            if (fieldType === 'number') {\n-                return ['equals', 'greaterThan', 'lessThan'].includes(key);\n-            }\n-            if (fieldType === 'string') {\n-                return ['equals', 'contains', 'startsWith', 'endsWith'].includes(key);\n-            }\n-            return ['equals'].includes(key);\n-        })\n-        .map(([key, op]) => `<option value=\"${key}\">${op.label}</option>`)\n-        .join('');\n-\n-    operatorSelect.innerHTML = availableOperators;\n-}\n-\n-function getFieldType(path) {\n-    const value = getNestedValue(window.appState.fullResponseData, path);\n-    if (typeof value === 'number') return 'number';\n-    if (typeof value === 'string') return 'string';\n-    return 'other';\n-}\n-\n export function filterResponse(query) {\n     if (!window.appState.lastResponse || typeof window.appState.lastResponse !== 'object') return;\n \n     const responseData = document.getElementById('response-data');\n"
                },
                {
                    "date": 1747662175902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,41 @@\n import { syntaxHighlight } from '../utils/formatting.js';\n import { getNestedValue } from '../utils/objectUtils.js';\n \n export function initFilterFunctionality() {\n+    // Setup dropdowns\n+    const filterTypeSelect = document.getElementById('filter-type');\n+    const filterOperatorSelect = document.getElementById('filter-operator');\n+\n+    // Show operator select when a field is selected\n+    if (filterTypeSelect) {\n+        filterTypeSelect.addEventListener('change', function () {\n+            if (this.value) {\n+                filterOperatorSelect.style.display = 'block';\n+                const fieldType = getFieldType(this.value);\n+                updateOperatorOptions(fieldType);\n+            } else {\n+                filterOperatorSelect.style.display = 'none';\n+            }\n+        });\n+    }\n+\n+    // Add operator options\n+    if (filterOperatorSelect) {\n+        const operators = {\n+            equals: 'equals',\n+            contains: 'contains',\n+            startsWith: 'starts with',\n+            endsWith: 'ends with',\n+            greaterThan: 'greater than',\n+            lessThan: 'less than'\n+        };\n+\n+        filterOperatorSelect.innerHTML = Object.entries(operators)\n+            .map(([key, label]) => `<option value=\"${key}\">${label}</option>`)\n+            .join('');\n+    }\n+\n     // Add filter event listeners\n     const applyFilterBtn = document.getElementById('apply-filter');\n     if (applyFilterBtn) {\n         applyFilterBtn.addEventListener('click', function () {\n@@ -578,4 +611,40 @@\n     // This function is no longer needed since we're using a hardcoded match operator\n     // But we'll keep it to fix the reference error\n     console.log('Filter operators updated');\n }\n+\n+function getFieldType(path) {\n+    const value = window.appState.fullResponseData ?\n+        getNestedValue(window.appState.fullResponseData, path) : null;\n+\n+    if (typeof value === 'number') return 'number';\n+    if (typeof value === 'string') return 'string';\n+    return 'other';\n+}\n+\n+function updateOperatorOptions(fieldType) {\n+    const operatorSelect = document.getElementById('filter-operator');\n+    if (!operatorSelect) return;\n+\n+    const numberOperators = ['equals', 'greaterThan', 'lessThan'];\n+    const stringOperators = ['equals', 'contains', 'startsWith', 'endsWith'];\n+    const defaultOperators = ['equals'];\n+\n+    let availableOperators;\n+    if (fieldType === 'number') availableOperators = numberOperators;\n+    else if (fieldType === 'string') availableOperators = stringOperators;\n+    else availableOperators = defaultOperators;\n+\n+    const operators = {\n+        equals: 'equals',\n+        contains: 'contains',\n+        startsWith: 'starts with',\n+        endsWith: 'ends with',\n+        greaterThan: 'greater than',\n+        lessThan: 'less than'\n+    };\n+\n+    operatorSelect.innerHTML = availableOperators\n+        .map(op => `<option value=\"${op}\">${operators[op]}</option>`)\n+        .join('');\n+}\n"
                },
                {
                    "date": 1747662423963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,11 +3,11 @@\n import { syntaxHighlight } from '../utils/formatting.js';\n import { getNestedValue } from '../utils/objectUtils.js';\n \n export function initFilterFunctionality() {\n-    // Setup dropdowns\n     const filterTypeSelect = document.getElementById('filter-type');\n     const filterOperatorSelect = document.getElementById('filter-operator');\n+    const filterValue = document.getElementById('filter-value');\n \n     // Show operator select when a field is selected\n     if (filterTypeSelect) {\n         filterTypeSelect.addEventListener('change', function () {\n"
                },
                {
                    "date": 1747662432201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,81 +7,66 @@\n     const filterTypeSelect = document.getElementById('filter-type');\n     const filterOperatorSelect = document.getElementById('filter-operator');\n     const filterValue = document.getElementById('filter-value');\n \n-    // Show operator select when a field is selected\n-    if (filterTypeSelect) {\n-        filterTypeSelect.addEventListener('change', function () {\n-            if (this.value) {\n-                filterOperatorSelect.style.display = 'block';\n-                const fieldType = getFieldType(this.value);\n-                updateOperatorOptions(fieldType);\n-            } else {\n-                filterOperatorSelect.style.display = 'none';\n-            }\n-        });\n-    }\n+    // Use event delegation for better performance\n+    document.addEventListener('change', (e) => {\n+        if (e.target === filterTypeSelect) {\n+            requestAnimationFrame(() => {\n+                updateOperatorOptions(getFieldType(e.target.value));\n+            });\n+        }\n+    });\n \n-    // Add operator options\n-    if (filterOperatorSelect) {\n-        const operators = {\n-            equals: 'equals',\n-            contains: 'contains',\n-            startsWith: 'starts with',\n-            endsWith: 'ends with',\n-            greaterThan: 'greater than',\n-            lessThan: 'less than'\n-        };\n+    // Debounce filter value input\n+    let timeoutId;\n+    filterValue?.addEventListener('input', () => {\n+        clearTimeout(timeoutId);\n+        timeoutId = setTimeout(() => {\n+            applyFilters();\n+        }, 300);\n+    });\n+}\n \n-        filterOperatorSelect.innerHTML = Object.entries(operators)\n-            .map(([key, label]) => `<option value=\"${key}\">${label}</option>`)\n-            .join('');\n-    }\n+// Optimize filter updates\n+function updateOperatorOptions(fieldType) {\n+    const operatorSelect = document.getElementById('filter-operator');\n+    if (!operatorSelect) return;\n \n-    // Add filter event listeners\n-    const applyFilterBtn = document.getElementById('apply-filter');\n-    if (applyFilterBtn) {\n-        applyFilterBtn.addEventListener('click', function () {\n-            const filterType = document.getElementById('filter-type');\n-            const filterOperator = document.getElementById('filter-operator');\n-            const filterValue = document.getElementById('filter-value');\n+    const availableOperators = getOperatorsForType(fieldType);\n+    operatorSelect.innerHTML = availableOperators\n+        .map(op => `<option value=\"${op.value}\">${op.label}</option>`)\n+        .join('');\n+}\n \n-            if (!filterType || !filterOperator || !filterValue) return;\n+function getOperatorsForType(fieldType) {\n+    const operators = {\n+        string: [\n+            { value: 'equals', label: 'equals' },\n+            { value: 'contains', label: 'contains' },\n+            { value: 'startsWith', label: 'starts with' },\n+            { value: 'endsWith', label: 'ends with' }\n+        ],\n+        number: [\n+            { value: 'equals', label: 'equals' },\n+            { value: 'greaterThan', label: 'greater than' },\n+            { value: 'lessThan', label: 'less than' }\n+        ],\n+        default: [\n+            { value: 'equals', label: 'equals' }\n+        ]\n+    };\n \n-            const typeVal = filterType.value;\n-            const operatorVal = filterOperator.value;\n-            const valueVal = filterValue.value;\n+    return operators[fieldType] || operators.default;\n+}\n \n-            if (!typeVal) {\n-                showNotification('Please select a field', 'warning');\n-                return;\n-            }\n-\n-            // For exclude operator, we need a value\n-            if (operatorVal === 'exclude' && !valueVal) {\n-                showNotification('Please enter a value to exclude', 'warning');\n-                return;\n-            }\n-\n-            applyFilterToResponse(typeVal, operatorVal, valueVal);\n-        });\n+// Cache DOM elements\n+const elements = new Map();\n+function getElement(id) {\n+    if (!elements.has(id)) {\n+        elements.set(id, document.getElementById(id));\n     }\n-\n-    // Set up filter type change handler for nested objects\n-    const filterType = document.getElementById('filter-type');\n-    if (filterType) {\n-        filterType.addEventListener('change', function () {\n-            updateSubFieldOptions(filterType.value);\n-        });\n-    }\n-\n-    // Filter input\n-    const filterQuery = document.getElementById('filter-query');\n-    if (filterQuery) {\n-        filterQuery.addEventListener('input', () => {\n-            if (window.appState.lastResponse) filterResponse(filterQuery.value);\n-        });\n-    }\n+    return elements.get(id);\n }\n \n export function filterResponse(query) {\n     if (!window.appState.lastResponse || typeof window.appState.lastResponse !== 'object') return;\n@@ -620,31 +605,4 @@\n     if (typeof value === 'number') return 'number';\n     if (typeof value === 'string') return 'string';\n     return 'other';\n }\n-\n-function updateOperatorOptions(fieldType) {\n-    const operatorSelect = document.getElementById('filter-operator');\n-    if (!operatorSelect) return;\n-\n-    const numberOperators = ['equals', 'greaterThan', 'lessThan'];\n-    const stringOperators = ['equals', 'contains', 'startsWith', 'endsWith'];\n-    const defaultOperators = ['equals'];\n-\n-    let availableOperators;\n-    if (fieldType === 'number') availableOperators = numberOperators;\n-    else if (fieldType === 'string') availableOperators = stringOperators;\n-    else availableOperators = defaultOperators;\n-\n-    const operators = {\n-        equals: 'equals',\n-        contains: 'contains',\n-        startsWith: 'starts with',\n-        endsWith: 'ends with',\n-        greaterThan: 'greater than',\n-        lessThan: 'less than'\n-    };\n-\n-    operatorSelect.innerHTML = availableOperators\n-        .map(op => `<option value=\"${op}\">${operators[op]}</option>`)\n-        .join('');\n-}\n"
                },
                {
                    "date": 1747662464022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,70 +3,52 @@\n import { syntaxHighlight } from '../utils/formatting.js';\n import { getNestedValue } from '../utils/objectUtils.js';\n \n export function initFilterFunctionality() {\n-    const filterTypeSelect = document.getElementById('filter-type');\n-    const filterOperatorSelect = document.getElementById('filter-operator');\n-    const filterValue = document.getElementById('filter-value');\n+    // Add filter event listeners\n+    const applyFilterBtn = document.getElementById('apply-filter');\n+    if (applyFilterBtn) {\n+        applyFilterBtn.addEventListener('click', function () {\n+            const filterType = document.getElementById('filter-type');\n+            const filterOperator = document.getElementById('filter-operator');\n+            const filterValue = document.getElementById('filter-value');\n \n-    // Use event delegation for better performance\n-    document.addEventListener('change', (e) => {\n-        if (e.target === filterTypeSelect) {\n-            requestAnimationFrame(() => {\n-                updateOperatorOptions(getFieldType(e.target.value));\n-            });\n-        }\n-    });\n+            if (!filterType || !filterOperator || !filterValue) return;\n \n-    // Debounce filter value input\n-    let timeoutId;\n-    filterValue?.addEventListener('input', () => {\n-        clearTimeout(timeoutId);\n-        timeoutId = setTimeout(() => {\n-            applyFilters();\n-        }, 300);\n-    });\n-}\n+            const typeVal = filterType.value;\n+            const operatorVal = filterOperator.value;\n+            const valueVal = filterValue.value;\n \n-// Optimize filter updates\n-function updateOperatorOptions(fieldType) {\n-    const operatorSelect = document.getElementById('filter-operator');\n-    if (!operatorSelect) return;\n+            if (!typeVal) {\n+                showNotification('Please select a field', 'warning');\n+                return;\n+            }\n \n-    const availableOperators = getOperatorsForType(fieldType);\n-    operatorSelect.innerHTML = availableOperators\n-        .map(op => `<option value=\"${op.value}\">${op.label}</option>`)\n-        .join('');\n-}\n+            // For exclude operator, we need a value\n+            if (operatorVal === 'exclude' && !valueVal) {\n+                showNotification('Please enter a value to exclude', 'warning');\n+                return;\n+            }\n \n-function getOperatorsForType(fieldType) {\n-    const operators = {\n-        string: [\n-            { value: 'equals', label: 'equals' },\n-            { value: 'contains', label: 'contains' },\n-            { value: 'startsWith', label: 'starts with' },\n-            { value: 'endsWith', label: 'ends with' }\n-        ],\n-        number: [\n-            { value: 'equals', label: 'equals' },\n-            { value: 'greaterThan', label: 'greater than' },\n-            { value: 'lessThan', label: 'less than' }\n-        ],\n-        default: [\n-            { value: 'equals', label: 'equals' }\n-        ]\n-    };\n+            applyFilterToResponse(typeVal, operatorVal, valueVal);\n+        });\n+    }\n \n-    return operators[fieldType] || operators.default;\n-}\n+    // Set up filter type change handler for nested objects\n+    const filterType = document.getElementById('filter-type');\n+    if (filterType) {\n+        filterType.addEventListener('change', function () {\n+            updateSubFieldOptions(filterType.value);\n+        });\n+    }\n \n-// Cache DOM elements\n-const elements = new Map();\n-function getElement(id) {\n-    if (!elements.has(id)) {\n-        elements.set(id, document.getElementById(id));\n+    // Filter input\n+    const filterQuery = document.getElementById('filter-query');\n+    if (filterQuery) {\n+        filterQuery.addEventListener('input', () => {\n+            if (window.appState.lastResponse) filterResponse(filterQuery.value);\n+        });\n     }\n-    return elements.get(id);\n }\n \n export function filterResponse(query) {\n     if (!window.appState.lastResponse || typeof window.appState.lastResponse !== 'object') return;\n@@ -596,13 +578,4 @@\n     // This function is no longer needed since we're using a hardcoded match operator\n     // But we'll keep it to fix the reference error\n     console.log('Filter operators updated');\n }\n-\n-function getFieldType(path) {\n-    const value = window.appState.fullResponseData ?\n-        getNestedValue(window.appState.fullResponseData, path) : null;\n-\n-    if (typeof value === 'number') return 'number';\n-    if (typeof value === 'string') return 'string';\n-    return 'other';\n-}\n"
                }
            ],
            "date": 1747661990453,
            "name": "Commit-0",
            "content": "import { showNotification } from '../utils/notifications.js';\nimport { formatResponse } from './formatToggle.js';\nimport { syntaxHighlight } from '../utils/formatting.js';\nimport { getNestedValue } from '../utils/objectUtils.js';\nimport { operators, applyFilters } from '../utils/filterUtils.js';\n\nexport function initFilterFunctionality() {\n    // Add filter event listeners\n    const applyFilterBtn = document.getElementById('apply-filter');\n    if (applyFilterBtn) {\n        applyFilterBtn.addEventListener('click', function () {\n            const filterType = document.getElementById('filter-type');\n            const filterOperator = document.getElementById('filter-operator');\n            const filterValue = document.getElementById('filter-value');\n\n            if (!filterType || !filterOperator || !filterValue) return;\n\n            const typeVal = filterType.value;\n            const operatorVal = filterOperator.value;\n            const valueVal = filterValue.value;\n\n            if (!typeVal) {\n                showNotification('Please select a field', 'warning');\n                return;\n            }\n\n            // For exclude operator, we need a value\n            if (operatorVal === 'exclude' && !valueVal) {\n                showNotification('Please enter a value to exclude', 'warning');\n                return;\n            }\n\n            applyFilterToResponse(typeVal, operatorVal, valueVal);\n        });\n    }\n\n    // Set up filter type change handler for nested objects\n    const filterType = document.getElementById('filter-type');\n    if (filterType) {\n        filterType.addEventListener('change', function () {\n            updateSubFieldOptions(filterType.value);\n        });\n    }\n\n    // Filter input\n    const filterQuery = document.getElementById('filter-query');\n    if (filterQuery) {\n        filterQuery.addEventListener('input', () => {\n            if (window.appState.lastResponse) filterResponse(filterQuery.value);\n        });\n    }\n\n    // Update operator select options\n    const filterOperator = document.getElementById('filter-operator');\n    if (filterOperator) {\n        filterOperator.innerHTML = Object.entries(operators)\n            .map(([key, op]) => `<option value=\"${key}\">${op.label}</option>`)\n            .join('');\n        filterOperator.style.display = 'inline-block';\n    }\n\n    // Show operator select based on field type\n    document.getElementById('filter-type').addEventListener('change', (e) => {\n        const fieldType = getFieldType(e.target.value);\n        updateOperatorOptions(fieldType);\n    });\n}\n\nfunction updateOperatorOptions(fieldType) {\n    const operatorSelect = document.getElementById('filter-operator');\n    if (!operatorSelect) return;\n\n    const availableOperators = Object.entries(operators)\n        .filter(([key, op]) => {\n            if (fieldType === 'number') {\n                return ['equals', 'greaterThan', 'lessThan'].includes(key);\n            }\n            if (fieldType === 'string') {\n                return ['equals', 'contains', 'startsWith', 'endsWith'].includes(key);\n            }\n            return ['equals'].includes(key);\n        })\n        .map(([key, op]) => `<option value=\"${key}\">${op.label}</option>`)\n        .join('');\n\n    operatorSelect.innerHTML = availableOperators;\n}\n\nfunction getFieldType(path) {\n    const value = getNestedValue(window.appState.fullResponseData, path);\n    if (typeof value === 'number') return 'number';\n    if (typeof value === 'string') return 'string';\n    return 'other';\n}\n\nexport function filterResponse(query) {\n    if (!window.appState.lastResponse || typeof window.appState.lastResponse !== 'object') return;\n\n    const responseData = document.getElementById('response-data');\n    if (!responseData) return;\n\n    if (!query) {\n        formatResponse(window.appState.prettyPrintEnabled);\n        return;\n    }\n\n    try {\n        const parts = query.split('.');\n        let result = window.appState.lastResponse;\n\n        for (let part of parts) {\n            if (!result) break;\n\n            if (part.includes('[') && part.includes(']')) {\n                const arrayName = part.substring(0, part.indexOf('['));\n                const indexStr = part.substring(part.indexOf('[') + 1, part.indexOf(']'));\n                const index = parseInt(indexStr);\n\n                result = arrayName ? result[arrayName]?.[index] : result[index];\n            } else {\n                result = result[part];\n            }\n        }\n\n        if (result === undefined || result === null) {\n            responseData.textContent = 'No results for this filter query';\n            return;\n        }\n\n        if (typeof result === 'object') {\n            responseData.innerHTML = syntaxHighlight(JSON.stringify(result, null, 4));\n        } else {\n            responseData.textContent = String(result);\n        }\n    } catch (e) {\n        console.error('Filter error:', e);\n        responseData.textContent = `Error applying filter: ${e.message}`;\n    }\n}\n\nexport function updateFilterFieldOptions(data) {\n    const filterTypeSelect = document.getElementById('filter-type');\n    if (!filterTypeSelect) {\n        console.error('Filter type select element not found.');\n        return;\n    }\n\n    // Reset filter UI\n    resetFilterUI();\n\n    // Store the full response data for later use in filtering\n    window.appState.fullResponseData = data;\n\n    // Identify the main array or object in the response\n    let mainData = data;\n\n    // Check if the data has a structure with nested arrays (like testRuns in your example)\n    if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n        const keys = Object.keys(data);\n        for (const key of keys) {\n            if (Array.isArray(data[key]) && data[key].length > 0) {\n                // Found an array property that might be the main data\n                const option = document.createElement('option');\n                option.value = key;\n                option.textContent = key;\n                filterTypeSelect.appendChild(option);\n            } else if (typeof data[key] === 'object' && data[key] !== null) {\n                // Found a nested object\n                const option = document.createElement('option');\n                option.value = key;\n                option.textContent = key;\n                filterTypeSelect.appendChild(option);\n            } else {\n                // Simple property\n                const option = document.createElement('option');\n                option.value = key;\n                option.textContent = key;\n                filterTypeSelect.appendChild(option);\n            }\n        }\n    } else if (Array.isArray(data)) {\n        // If it's directly an array\n        mainData = data;\n\n        // If it's an array of objects, add \"[root]\" option\n        if (data.length > 0 && typeof data[0] === 'object') {\n            const option = document.createElement('option');\n            option.value = \"[root]\";\n            option.textContent = \"Array Items\";\n            filterTypeSelect.appendChild(option);\n        }\n    }\n\n    // Update filter operator options\n    updateFilterOperators();\n}\n\nfunction resetFilterUI() {\n    const filterTypeSelect = document.getElementById('filter-type');\n    const filterOperator = document.getElementById('filter-operator');\n    const filterValue = document.getElementById('filter-value');\n\n    // Clear existing options\n    while (filterTypeSelect.options.length > 0) {\n        filterTypeSelect.remove(0);\n    }\n\n    // Add default option\n    const defaultOption = document.createElement('option');\n    defaultOption.value = \"\";\n    defaultOption.textContent = \"Select Path\";\n    defaultOption.selected = true;\n    filterTypeSelect.appendChild(defaultOption);\n\n    // Reset other fields\n    if (filterValue) filterValue.value = '';\n\n    // Remove any sub-field selects\n    const subFieldContainer = document.getElementById('sub-field-container');\n    if (subFieldContainer) {\n        while (subFieldContainer.firstChild) {\n            subFieldContainer.removeChild(subFieldContainer.firstChild);\n        }\n    }\n}\n\nfunction updateSubFieldOptions(selectedPath) {\n    if (!selectedPath || !window.appState.fullResponseData) return;\n\n    // Create or get the sub-field container\n    let subFieldContainer = document.getElementById('sub-field-container');\n    if (!subFieldContainer) {\n        subFieldContainer = document.createElement('div');\n        subFieldContainer.id = 'sub-field-container';\n        subFieldContainer.className = 'sub-field-container';\n\n        // Insert after the main filter type\n        const filterType = document.getElementById('filter-type');\n        filterType.parentNode.insertBefore(subFieldContainer, filterType.nextSibling);\n    }\n\n    // Clear existing sub-fields\n    while (subFieldContainer.firstChild) {\n        subFieldContainer.removeChild(subFieldContainer.firstChild);\n    }\n\n    let targetData;\n\n    // Different handling for root array\n    if (selectedPath === \"[root]\" && Array.isArray(window.appState.fullResponseData)) {\n        targetData = window.appState.fullResponseData[0]; // First item in the array\n    } else {\n        // Handle array path (e.g., \"testRuns\")\n        const isArrayPath = Array.isArray(getNestedValue(window.appState.fullResponseData, selectedPath));\n\n        if (isArrayPath) {\n            // For array paths, get the first item to see the structure\n            const arrayData = getNestedValue(window.appState.fullResponseData, selectedPath);\n            targetData = arrayData && arrayData.length > 0 ? arrayData[0] : null;\n\n            // Create a label to show we're exploring array items\n            const arrayLabel = document.createElement('div');\n            arrayLabel.className = 'filter-path-label';\n            arrayLabel.textContent = `Showing fields from ${selectedPath}[0]`;\n            subFieldContainer.appendChild(arrayLabel);\n        } else {\n            targetData = getNestedValue(window.appState.fullResponseData, selectedPath);\n        }\n    }\n\n    // For non-object data, show the value\n    if (targetData !== undefined && (typeof targetData !== 'object' || targetData === null)) {\n        const valueDisplay = document.createElement('div');\n        valueDisplay.className = 'filter-value-display';\n        valueDisplay.textContent = `Value: ${JSON.stringify(targetData)}`;\n        subFieldContainer.appendChild(valueDisplay);\n        return;\n    }\n\n    // If we have an object with properties\n    if (typeof targetData === 'object' && targetData !== null) {\n        const subSelect = document.createElement('select');\n        subSelect.className = 'filter-select sub-field-select';\n\n        // Default option\n        const defaultOption = document.createElement('option');\n        defaultOption.value = \"\";\n        defaultOption.textContent = \"Select Property\";\n        defaultOption.selected = true;\n        subSelect.appendChild(defaultOption);\n\n        // Add options for each property\n        for (const key of Object.keys(targetData)) {\n            const option = document.createElement('option');\n            option.value = key;\n            option.textContent = key;\n            subSelect.appendChild(option);\n        }\n\n        // Event listener for property selection\n        subSelect.addEventListener('change', function () {\n            if (!subSelect.value) return;\n\n            const fullPath = selectedPath === \"[root]\" ?\n                subSelect.value :\n                `${selectedPath}.${subSelect.value}`;\n\n            // Check if this is an object property that can be further explored\n            const propertyValue = getNestedValue(window.appState.fullResponseData, fullPath);\n\n            if (typeof propertyValue === 'object' && propertyValue !== null && !Array.isArray(propertyValue)) {\n                // Handle nested object\n                const combinedPath = fullPath;\n                updateNestedSubFields(combinedPath, subFieldContainer, subSelect);\n            } else {\n                // For primitive values or arrays, show available values\n                displayFieldValues(fullPath, subFieldContainer, subSelect);\n            }\n        });\n\n        subFieldContainer.appendChild(subSelect);\n    }\n}\n\n// Add this new function to extract unique values for a given path\nfunction extractUniqueValues(data, path) {\n    if (!data || !path) return [];\n\n    // Get the value at the given path\n    let values = [];\n    let targetData = getNestedValue(data, path);\n\n    // Handle array data specifically (most common case)\n    if (Array.isArray(targetData)) {\n        // This is an array of objects most likely, so we return the array\n        return targetData;\n    }\n\n    // Find all values in the data structure that match this path\n    // This is useful when we have an array of objects and looking for all values of a specific field\n    if (Array.isArray(data)) {\n        // Path might be a property of items in this array\n        const fieldParts = path.split('.');\n        const lastField = fieldParts[fieldParts.length - 1];\n\n        data.forEach(item => {\n            if (typeof item === 'object' && item !== null) {\n                const itemValue = fieldParts.length === 1 ?\n                    item[lastField] :\n                    getNestedValue(item, path);\n\n                if (itemValue !== undefined && !values.includes(itemValue)) {\n                    values.push(itemValue);\n                }\n            }\n        });\n    }\n\n    return values;\n}\n\n// New function to display all available values for a selected field\nfunction displayFieldValues(path, container, previousSelect) {\n    // Remove any elements after the current select\n    let next = previousSelect.nextSibling;\n    while (next) {\n        const toRemove = next;\n        next = next.nextSibling;\n        container.removeChild(toRemove);\n    }\n\n    // Get array data that contains this path\n    let arrayData;\n    const pathParts = path.split('.');\n    let arrayPath = \"\";\n\n    // Find the array in the path if any\n    for (let i = 0; i < pathParts.length; i++) {\n        const currentPath = pathParts.slice(0, i + 1).join('.');\n        const currentData = getNestedValue(window.appState.fullResponseData, currentPath);\n\n        if (Array.isArray(currentData)) {\n            arrayPath = currentPath;\n            arrayData = currentData;\n            break;\n        }\n    }\n\n    if (!arrayPath && Array.isArray(window.appState.fullResponseData)) {\n        // Root is an array\n        arrayData = window.appState.fullResponseData;\n    }\n\n    // Extract unique values for this field\n    const values = new Set();\n    const fieldName = pathParts[pathParts.length - 1];\n\n    if (arrayData) {\n        // If we have array data, extract values from it\n        arrayData.forEach(item => {\n            // If the field is directly on the array items\n            if (pathParts.length === 1 || path.startsWith('[root].')) {\n                if (item && typeof item === 'object' && item[fieldName] !== undefined) {\n                    values.add(String(item[fieldName]));\n                }\n            } else {\n                // For nested fields, we need to get the relevant part of the path\n                const relPathParts = arrayPath === \"\" ?\n                    pathParts :\n                    pathParts.slice(pathParts.indexOf(arrayPath.split('.').pop()) + 1);\n\n                let currentItem = item;\n                for (let i = 0; i < relPathParts.length - 1; i++) {\n                    if (!currentItem || typeof currentItem !== 'object') break;\n                    currentItem = currentItem[relPathParts[i]];\n                }\n\n                if (currentItem && typeof currentItem === 'object' && currentItem[fieldName] !== undefined) {\n                    values.add(String(currentItem[fieldName]));\n                }\n            }\n        });\n    } else {\n        // If no array in the path, just get the single value\n        const value = getNestedValue(window.appState.fullResponseData, path);\n        if (value !== undefined) values.add(String(value));\n    }\n\n    // Create value selector\n    if (values.size > 0) {\n        const valueSelect = document.createElement('select');\n        valueSelect.className = 'filter-select value-select';\n\n        const defaultOption = document.createElement('option');\n        defaultOption.value = \"\";\n        defaultOption.textContent = `Available ${fieldName} values (${values.size})`;\n        defaultOption.selected = true;\n        valueSelect.appendChild(defaultOption);\n\n        // Convert set to array and sort for consistent display\n        Array.from(values).sort().forEach(val => {\n            const option = document.createElement('option');\n            option.value = val;\n            option.textContent = val;\n            valueSelect.appendChild(option);\n        });\n\n        // When a value is selected, apply a filter to show only matching items\n        valueSelect.addEventListener('change', function () {\n            if (!valueSelect.value) return;\n\n            const filterValue = valueSelect.value;\n            createFilterTag(path, fieldName, filterValue, 'match');\n        });\n\n        container.appendChild(valueSelect);\n    } else {\n        const noValues = document.createElement('div');\n        noValues.className = 'no-values-message';\n        noValues.textContent = 'No values found for this field';\n        container.appendChild(noValues);\n    }\n}\n\n// Helper to create filter tags\nfunction createFilterTag(path, fieldName, value, operator) {\n    const activeFilters = document.getElementById('active-filters');\n    if (!activeFilters) return;\n\n    const filterTag = document.createElement('div');\n    filterTag.className = 'filter-tag';\n\n    // Format the display\n    filterTag.innerHTML = `\n        ${fieldName} = \"${value}\"\n        <span class=\"remove-filter\"><i class=\"fas fa-times\"></i></span>\n    `;\n\n    filterTag.querySelector('.remove-filter')?.addEventListener('click', () => {\n        filterTag.remove();\n        applyAllFilters();\n    });\n\n    // Store filter data\n    filterTag.dataset.path = path;\n    filterTag.dataset.operator = operator;\n    filterTag.dataset.value = value;\n\n    activeFilters.appendChild(filterTag);\n    applyAllFilters();\n}\n\n// Update this function for our revised filtering approach\nfunction applyAllFilters() {\n    if (!window.appState.fullResponseData) return;\n\n    const responseData = document.getElementById('response-data');\n    if (!responseData) return;\n\n    const filterTags = document.querySelectorAll('.filter-tag');\n    if (!filterTags || filterTags.length === 0) {\n        // If no filters, show original data\n        formatResponse(window.appState.prettyPrintEnabled);\n        return;\n    }\n\n    // Create a mapping of paths to filter criteria\n    const filters = [];\n    filterTags.forEach(tag => {\n        filters.push({\n            path: tag.dataset.path,\n            operator: tag.dataset.operator,\n            value: tag.dataset.value\n        });\n    });\n\n    // Start with a deep copy of the original data\n    let resultData = JSON.parse(JSON.stringify(window.appState.fullResponseData));\n\n    // Apply filters - we'll focus mostly on filtering array data\n    for (const filter of filters) {\n        resultData = applyFilter(resultData, filter);\n    }\n\n    // Update the display with filtered data\n    responseData.innerHTML = syntaxHighlight(JSON.stringify(resultData, null, 2));\n}\n\n// New approach to apply filters\nfunction applyFilter(data, filter) {\n    // Find if we're filtering an array\n    const pathParts = filter.path.split('.');\n    let currentData = data;\n    let currentPath = '';\n    let arrayPath = null;\n\n    // Find the array in the path\n    for (let i = 0; i < pathParts.length; i++) {\n        if (currentPath) {\n            currentPath += '.';\n        }\n        currentPath += pathParts[i];\n\n        if (Array.isArray(getNestedValue(data, currentPath))) {\n            arrayPath = currentPath;\n            break;\n        }\n    }\n\n    // If no array was found in the path but the root is an array\n    if (!arrayPath && Array.isArray(data)) {\n        arrayPath = ''; // Root array\n    }\n\n    // If we found an array, filter it\n    if (arrayPath !== null) {\n        return filterDataArray(data, arrayPath, filter);\n    }\n\n    // If no array to filter, return the original data\n    return data;\n}\n\n// Filter an array at the given path\nfunction filterDataArray(data, arrayPath, filter) {\n    const result = JSON.parse(JSON.stringify(data));\n    const targetArray = arrayPath ? getNestedValue(result, arrayPath) : result;\n\n    if (!Array.isArray(targetArray)) return result;\n\n    // Get the field to filter on (relative to array items)\n    const fullPath = filter.path;\n    let fieldPath;\n\n    if (arrayPath === '') {\n        // Root array\n        fieldPath = fullPath;\n    } else {\n        // Get the part of the path after the array\n        const arrayPathParts = arrayPath.split('.');\n        const fullPathParts = fullPath.split('.');\n        fieldPath = fullPathParts.slice(arrayPathParts.length).join('.');\n    }\n\n    // Filter the array\n    const filtered = targetArray.filter(item => {\n        if (!item || typeof item !== 'object') return false;\n\n        // Get the value from the item\n        const itemValue = fieldPath.includes('.') ?\n            getNestedValue(item, fieldPath) :\n            item[fieldPath];\n\n        if (itemValue === undefined) return false;\n\n        // Apply the filter condition\n        if (filter.operator === 'match') {\n            return String(itemValue) === filter.value;\n        }\n        return true; // Default case\n    });\n\n    // Update the array in the result\n    if (arrayPath) {\n        // For a nested array\n        const parts = arrayPath.split('.');\n        let current = result;\n        for (let i = 0; i < parts.length - 1; i++) {\n            current = current[parts[i]];\n        }\n        current[parts[parts.length - 1]] = filtered;\n    } else {\n        // For a root array\n        return filtered;\n    }\n\n    return result;\n}\n\nfunction updateFilterOperators() {\n    // This function is no longer needed since we're using a hardcoded match operator\n    // But we'll keep it to fix the reference error\n    console.log('Filter operators updated');\n}\n"
        }
    ]
}